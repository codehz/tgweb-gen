/** @jsx h */
/** @jsxFrag Fragment */

import { Database } from "https://deno.land/x/sqlite3@0.4.2/mod.ts";
import {
  Command,
  string,
  number,
  ArgumentType,
} from "https://deno.land/x/clay@v0.2.5/mod.ts";
import {
  h,
  Fragment,
  renderToString,
} from "https://deno.land/x/jsx@v0.1.5/mod.ts";

import { Message, MessageEntity, PhotoSize, Document } from "./types.d.ts";

const databasefile: ArgumentType<Database> = {
  parse(raw) {
    return new Database(raw);
  },
  typeName: "database",
};

const textfile: ArgumentType<string> = {
  parse(raw) {
    return Deno.readTextFileSync(raw);
  },
  typeName: "textfile",
};

const {
  database,
  output,
  channel,
  style,
  script,
  cache,
  head: extra_head,
  footer,
} = new Command("tgweb-generate")
  .required(databasefile, "database", {
    flags: ["i", "input"],
    description: "The database file (generated by tg-channel-dumper)",
  })
  .required(string, "output", {
    flags: ["o", "output"],
    description: "The output html file",
  })
  .required(string, "cache", {
    flags: ["cache"],
    description: "The cache file path",
  })
  .required(number, "channel", {
    flags: ["channel"],
    description: "Target channel id",
  })
  .optional(textfile, "head", { flags: ["head"] })
  .optional(textfile, "footer", { flags: ["footer"] })
  .optional(textfile, "style", { flags: ["style"] })
  .optional(textfile, "script", { flags: ["script"] })
  .run();

function renderMessage(text: string, entities: MessageEntity[]) {
  const chunks: any[] = [];
  let last = 0;
  let entity: MessageEntity | undefined;
  for (let i = 0; i <= text.length; i++) {
    const matched = entities.find(
      (x) => x.offset <= i && x.offset + x.length > i
    );
    if (matched != entity) {
      const selected = text.slice(last, i);
      if (entity) {
        if (entity._ == "messageEntityUrl") {
          let target = selected;
          if (!target.match(/.*?:\/\//)) target = "http://" + target;
          chunks.push(<a href={target}>{selected}</a>);
        } else if (entity._ == "messageEntityTextUrl") {
          chunks.push(<a href={entity.url}>{selected}</a>);
        } else if (entity._ == "messageEntityStrike") {
          chunks.push(<del>{selected}</del>);
        } else if (entity._ == "messageEntityBold") {
          chunks.push(<strong>{selected}</strong>);
        } else if (entity._ == "messageEntityEmail") {
          chunks.push(<a href={"mailto:" + selected}>{selected}</a>);
        } else if (entity._ == "messageEntityCode") {
          chunks.push(<code>{selected}</code>);
        } else if (entity._ == "messageEntityPre") {
          chunks.push(<pre>{selected}</pre>);
        } else {
          const { _: type, offset, length, ...remain } = entity;
          chunks.push(
            <tg-message-entity type={type} {...remain}>
              {selected}
            </tg-message-entity>
          );
        }
      } else {
        chunks.push(selected);
      }
      last = i;
      entity = matched;
    }
  }
  const rest = text.slice(last);
  if (rest.length) {
    chunks.push(rest);
  }
  return chunks;
}

function encodeU64(int: bigint) {
  return BigInt.asUintN(64, int).toString(16).toUpperCase().padStart(16, "0");
}

function findsize(sizes: PhotoSize[]) {
  const sorted = [...sizes].filter((x) => x.h).sort((a, b) => a.w! - b.w!) as {
    w: number;
    h: number;
  }[];
  return sorted[0];
}

type DocumentInfo = {
  size: number;
  date: number;
  mime_type: string;
  file_name?: string;
};

function documentinfo(doc: Document) {
  const info: DocumentInfo = {
    size: doc.size,
    date: doc.date,
    mime_type: doc.mime_type,
  };
  for (const attr of doc.attributes) {
    if (attr._ === "documentAttributeFilename") {
      info.file_name = attr.file_name;
    }
  }
  return info;
}

try {
  const channels = database.queryArray<
    [string, string]
  >`SELECT title, about FROM channels WHERE id=${channel}`;
  if (channels.length == 0) {
    throw new Error("Channel not found in db");
  }
  const [title, about] = channels[0];
  const messages = database.queryArray<
    [number, string]
  >`SELECT msg_id, content FROM messages WHERE chat_id=${channel} ORDER BY msg_id DESC`.map(
    ([id, content]) => {
      const parsed = JSON.parse(content) as Message;
      if (parsed._ == "message") {
        let message: any = parsed.message;
        if (parsed.entities) {
          message = renderMessage(parsed.message, parsed.entities);
        }
        let media;
        if (parsed.media) {
          if (parsed.media._ == "messageMediaPhoto") {
            const id = encodeU64(BigInt(parsed.media.photo.id));
            const { w: width = "", h: height = "" } =
              findsize(parsed.media.photo.sizes) ?? {};
            media = message.length ? (
              <img
                src={cache + "/" + id}
                loading="lazy"
                width={width}
                height={height}
              />
            ) : (
              <img
                src={cache + "/" + id}
                loading="lazy"
                width={width}
                height={height}
                class="only"
              />
            );
          } else if (parsed.media._ == "messageMediaDocument") {
            const { file_name, ...rest } = documentinfo(parsed.media.document);
            media = (
              <tg-message-document {...rest}>{file_name}</tg-message-document>
            );
          }
        }
        return (
          <tg-message
            id={"msg-" + id}
            msgid={id}
            date={parsed.date}
            group={parsed.grouped_id ?? ""}
            edit_date={parsed.edit_date ?? ""}
          >
            {media}
            {message}
          </tg-message>
        );
      } else if ("title" in parsed.action)
        return (
          <tg-service-message
            id={"msg-" + id}
            msgid={id}
            date={parsed.date}
            action={parsed.action._}
            newtitle={parsed.action.title}
          />
        );
    }
  );
  const head = (
    <>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>{title}</title>
      <meta name="description" content={about} />
      <meta name="chat" content={channel} />
    </>
  );
  const body = (
    <>
      <tg-header>
        <h1>{title}</h1>
      </tg-header>
      <tg-content>
        <div class="messages">{messages}</div>
      </tg-content>
    </>
  );

  let html = `<!doctype html><!--generated-->`;
  html += await renderToString(head);
  if (style) html += `<style>${style}</style>`;
  if (extra_head) html += extra_head;
  html += await renderToString(body);
  if (footer) html += `<tg-footer>${footer}</tg-footer>`;
  if (script) html += `<script type="module">${script}</script>`;
  await Deno.writeTextFile(output, html);
} finally {
  database.close();
}
